from constants import *
import socket
import struct
import selectors
import db


"""
this class represent request the request. we unpack each request with the proper
format.
"""

class Request:
    def __init__(self, header):
        self.uid, self.client_version, self.request_code, self.payload_size = struct.unpack(REQUEST_HEADER_FORMAT,
                                                                                            header)
        self.payload = None

    def setPayload(self, pl):
        self.payload = pl


"""
returns username without padding.
"""


def extractUserName(name):
    return str(name, 'utf-8').rstrip('\0')


"""
generic function that I used in order to make custom headers.
The function gets the opcode and the payload size and pack it into
a struct. RESPONSE_HEADER_FORMAT is to define the types that we'll have
in the struct. The rest, are what were packing.
"""


def makeHeader(code, plSize):
    return struct.pack(RESPONSE_HEADER_FORMAT, SERVER_VER, code, plSize)


"""
returns internal error response (code 9000)
"""


def errorMsg():
    return makeHeader(INTERNAL_ERROR, 0)


"""
Attempts to register the given username with the public key.
user id will be generated by uuid module. 
"""


def registerUser(name, pubKey):
    try:
        userID = db.insertClient(name, pubKey)
        return makeHeader(REG_SUCC, UUID_SIZE) + userID
    except:
        return errorMsg()


"""
gets the list of users from db
"""


def getUserList(uid):
    db.updateConnTime(uid)
    uList = db.getUsersList(uid)
    msg = makeHeader(GET_ULIST_SUCC, len(uList)) + uList
    return msg


"""
gets the public key for the specified request.
"""


def getPublicKey(request):
    uid = request.payload
    db.updateConnTime(request.uid)
    try:
        msg = makeHeader(GET_PUB_KEY_SUCC, UUID_SIZE + PUB_KEY_SIZE) + uid + db.getUserPubKey(uid)
        return msg
    except:
        return errorMsg()


"""
saves the message for the dst user.
"""


def sendMessage(request):
    src = request.uid
    db.updateConnTime(src)
    dst = request.payload[:UUID_SIZE]
    msgType = struct.pack('B', request.payload[UUID_SIZE])
    txt = request.payload[MSG_CONTENT_OFFSET:]
    msgID = db.saveMsg(dst, src, msgType, txt)
    return makeHeader(MSG_SENT_SUCC, MSG_SENT_PAYLOAD_SIZE) + request.payload[:UUID_SIZE] + struct.pack('<I', msgID)


"""
returns the pending messages for the specified user.
"""


def getMessages(request):
    db.updateConnTime(request.uid)
    content = db.getMessages(request.uid)
    header = makeHeader(GET_MSGS_SUCC, len(content))
    return header + content


"""
gets a request and handle's it based on request_code field.
"""


def requestHandler(request):
    if request.request_code == REGISTER_USER:
        userName = extractUserName(request.payload[:USERNAME_SIZE])
        publicKey = request.payload[USERNAME_SIZE:]
        return registerUser(userName, publicKey)
    elif request.request_code == GET_USERLIST:
        return getUserList(request.uid)
    elif request.request_code == GET_PUBLICKEY:
        return getPublicKey(request)
    elif request.request_code == GET_PENDING_MSG:
        return getMessages(request)
    elif request.request_code == SEND_MSG:
        return sendMessage(request)
    else:
        print('Invalid request code. ' + request.request_code)


sel = selectors.DefaultSelector()


def accept(sock, mask):
    conn, addr = sock.accept()
    conn.setblocking(False)
    sel.register(conn, selectors.EVENT_READ, read)


def read(conn, mask):
    try:
        header = conn.recv(REQUEST_HEADER_SIZE)
        request = Request(header)
        data = bytearray()
        while len(data) < request.payload_size:
            packet = conn.recv(request.payload_size - len(data))
            data.extend(packet)
        request.setPayload(data)
        res = requestHandler(request)
        conn.sendall(res)
    except:
        print('Something went wrong with last connection')
    finally:
        sel.unregister(conn)
        conn.close()


def main():
    # Binding a socket to all network interfaces should be AVIODED.
    host = ''
    f = open("port.info", "r")
    port = int(f.read())
    # if db file doesn't exist, make it
    try:
        db.createDB()
    except:
        print('db already exists')
    sock = socket.socket()
    sock.bind((host, port))
    sock.listen()
    sock.setblocking(False)
    sel.register(sock, selectors.EVENT_READ, accept)
    while True:
        events = sel.select()
        for key, mask in events:
            callback = key.data
            callback(key.fileobj, mask)


if __name__ == '__main__':
    main()
